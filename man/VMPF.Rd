% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optim_vmpf.R
\name{VMPF}
\alias{VMPF}
\title{VMPF: Variance Minimization of the Predicted Front}
\usage{
VMPF(model, fun, nsteps, lower = rep(0, model@d), upper = rep(1, model@d),
  quiet = TRUE, control = NULL, modelcontrol = NULL)
}
\arguments{
\item{model}{An object of class \code{\link{mkm}},}

\item{fun}{The multi-objective and constraint cost function to be optimized.
This function must return a vector with the size of \code{model@m +
model@j} where \code{model@m} are the number of objectives and
\code{model@j} the number of the constraints,}

\item{nsteps}{An integer representing the desired number of iterations,}

\item{lower}{Vector of lower bounds for the variables to be optimized over
(default: 0 with length \code{model@d}),}

\item{upper}{Vector of upper bounds for the variables to be optimized over
(default: 1 with length \code{model@d}),}

\item{quiet}{Logical indicating the verbosity of the routine,}

\item{control}{An optional list of control parameters that controlls the
optimization algorithm. One can control: \describe{
\item{\code{popsize}}{(default: \code{200});}
\item{\code{generations}}{(default: \code{30});}
\item{\code{cdist}}{(default: \code{1/model@d});}
\item{\code{mprob}}{(default: \code{15});}
\item{\code{mdist}}{(defult: \code{20}).}
}}

\item{modelcontrol}{An optional list of control parameters to the
\code{mkm} function (default: \code{object@control}).}
}
\value{
an updated object of class \code{mkm}.
}
\description{
Executes \code{nsteps} iterations of the VMPF algorithm to an object of class
\code{\link{mkm}}. At each step, a multi-objective kriging model is re-estimated
(including covariance parameters re-estimation).
}
\details{
The infill point is sampled from the most uncertain design of a predicted
Pareto set. This set is predicted using nsga-2 algorithm and the mean value
of the mkm predictor.
}
\examples{
# ----------------
# Fonseca and Flemming
# ----------------
n <- 20
d <- 2
m <- 2
A <- 4
fun <- Fonseca
doe <- 2*A*replicate(d,sample(0:n,n))/n - A
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res, modelcontrol=list(lower=rep(0.1,d)))
model <- VMPF(model, fun, 20, lower = -rep(A,d), upper = rep(A,d), quiet = FALSE)
tpf <- mco::nsga2(fun, d, 2, lower.bounds = -rep(A,d), upper.bounds = rep(A,d))$value
plot(tpf)
points(ps(model@response)$set, col = 'blue', pch = 19)

# ----------------
# Shaffer1
# ----------------
n <- 10
d <- 1
A <- 10
fun <- Shaffer1
doe <- 2*A*replicate(d,sample(0:n,n))/n - A
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res)
model <- VMPF(model, fun, 20, lower = -A, upper = A, quiet = FALSE)
tpf <- mco::nsga2(fun, d, 2, lower.bounds = -A, upper.bounds = A)$value
plot(tpf)
points(ps(model@response)$set, col = 'blue', pch = 19)

# ----------------
# Shaffer2
# ----------------
n <- 10
d <- 1
fun <- Shaffer2
doe <- 15 * replicate(d,sample(0:n,n))/n - 5
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res)
model <- VMPF(model, fun, 20, lower = -5, upper = 10, quiet = FALSE)
tpf <- mco::nsga2(fun, d, 2, lower.bounds = -5, upper.bounds = 10)$value
plot(tpf)
points(ps(model@response)$set, col = 'blue', pch = 19)

# ----------------
# Viennet
# ----------------
n <- 20
d <- 2
fun <- Viennet
doe <- replicate(d,sample(0:n,n))/n
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res, modelcontrol=list(lower=rep(0.1,d)))
model <- VMPF(model, fun, 80, quiet = FALSE)
pairs(ps(model@response)$set)
rgl::plot3d(ps(model@response)$set)

# ----------------
# Binh
# ----------------
n <- 20
d <- 2
fun <- Binh
doe <- cbind(rep(5,n), rep(3,n)) * replicate(d,sample(0:n,n))/n
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res, modelcontrol = list(objectives = 1:2))
model <- VMPF(model, fun, 40, upper = c(5,3), quiet = FALSE)
fun <- function(x) Binh(x)[c(1,2)]
gfun <- function(x) -Binh(x)[-c(1,2)]
tpf <- mco::nsga2(fun, d, 2, lower.bounds = c(0,0), upper.bounds = c(5,3),
                   constraints = gfun, cdim = 2)$value
plot(tpf)
points(ps(model@response[which(model@feasible),model@objective])$set, col = 'blue', pch = 19)

# ----------------
# The Nowacki Beam
# ----------------
n <- 20
d <- 2
fun <- nowacki_beam
doe <- replicate(d,sample(0:n,n))/n
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res, modelcontrol = list(objective = 1:2, lower=rep(0.1,d)))
model <- VMPF(model, fun, 20, quiet = FALSE)
fun <- function(x) nowacki_beam(x)[c(1,2)]
gfun <- function(x) -nowacki_beam(x)[-c(1,2)]
tpf <- mco::nsga2(fun, d, 2, lower.bounds = c(0,0), upper.bounds = c(1,1),
                   constraints = gfun, cdim = 4)$value
plot(tpf)
points(ps(model@response[which(model@feasible),model@objective])$set, col = 'blue', pch = 19)

# -----------------------------
# Fonseca and Fleming function
# -----------------------------
n <- 20
d <- 5 #verificar pq >10 nao funfa
doe <- replicate(d, sample(0:n,n))/n
res <- t(apply(doe, 1, tf_ff))
model <- mkm(doe, res, modelcontrol = list(objective = 1:2, lower=rep(0.1,d)))
model <- VMPF(model, tf_ff, 80, quiet = FALSE)
plot(model@response, pch=19)
}

