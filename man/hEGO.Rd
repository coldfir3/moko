% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optim_hego.R
\name{hEGO}
\alias{hEGO}
\title{Title}
\usage{
hEGO(model, fun, nsteps, lower = rep(0, model@d), upper = rep(1, model@d),
  quiet = TRUE, control = NULL, optimcontrol = list(max.time = 2))
}
\arguments{
\item{model}{object of class \code{mkm} containing the objectives and constrains}

\item{lower}{
        Vector with length of \code{par}. Lower bounds for components.
    }

\item{upper}{
        Vector with length of \code{par}. Upper bounds for components.
    }

\item{control}{
        The argument is a list that can be used to control the behavior of the algorithm:
            \describe{
                \item{\code{maxit}}{
                    Integer. Maximum number of iterations of the algorithm. 
                }
                \item{\code{threshold.stop}}{
                    Numeric. The program will stop when the expected objective function value \code{threshold.stop} is reached. Default value is \code{NULL}
                }
                \item{\code{nb.stop.improvement}}{
                    Integer. The program will stop when there is no any improvement in \code{nb.stop.improvement} steps. 
                }
                \item{\code{smooth}}{
                    Logical.\code{TRUE} when the objective function is smooth, or differentiable almost everywhere in the
                        region of \code{par}, \code{FALSE} otherwise. Default value is \code{TRUE}.
                }
                \item{\code{max.call}}{
                    Integer. Maximum number of call of the objective function. Default is set to 1e7.
                }
                \item{\code{max.time}}{
                    Numeric. Maximum running time in seconds.
                }
                \item{\code{temperature}}{
                    Numeric. Initial value for temperature.
                }
                \item{\code{visiting.param}}{
                    Numeric. Parameter for visiting distribution.
                }
                \item{\code{acceptance.param}}{
                    Numeric. Parameter for acceptance distribution.
                }
                \item{\code{verbose}}{
                    Logical. \code{TRUE} means that messages from the algorithm are shown. Default is \code{FALSE}.
                }
                \item{\code{simple.function}}{
                    Logical. \code{FALSE} means that the objective function has only a few local minima. Default is \code{FALSE} which means that the objective function is complicated with many local minima.
                }
                \item{\code{trace.mat}}{
                    Logical. Default is \code{TRUE} which means that the trace matrix will be available in the returned value of \code{GenSA} call.
                }
            }
    }
}
\value{
updated \link{\code{mkm}} model
}
\description{
Description
}
\examples{
# ----------------
# Fonseca and Flemming
# ----------------
n <- 20
d <- 2
m <- 2
A <- 1 #verificar pq 4 nao funfa
fun <- Fonseca
doe <- 2*A*replicate(d,sample(0:n,n))/n - A
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res)
model <- hEGO(model, fun, 20, lower = -rep(A,d), upper = rep(A,d), quiet = FALSE)
tpf <- mco::nsga2(fun, d, 2, lower.bounds = -rep(A,d), upper.bounds = rep(A,d))$value
plot(tpf)
points(ps(model@response)$set, col = 'blue', pch = 19)
# ----------------
# Shaffer1
# ----------------
n <- 10
d <- 1
A <- 10
fun <- Shaffer1
doe <- 2*A*replicate(d,sample(0:n,n))/n - A
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res)
model <- hEGO(model, fun, 20, lower = -A, upper = A, quiet = FALSE)
tpf <- mco::nsga2(fun, d, 2, lower.bounds = -A, upper.bounds = A)$value
plot(tpf)
points(ps(model@response)$set, col = 'blue', pch = 19)
# ----------------
# Shaffer2
# ----------------
n <- 10
d <- 1
fun <- Shaffer2
doe <- 15 * replicate(d,sample(0:n,n))/n - 5
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res)
model <- hEGO(model, fun, 20, lower = -5, upper = 10, quiet = FALSE)
tpf <- mco::nsga2(fun, d, 2, lower.bounds = -5, upper.bounds = 10)$value
plot(tpf)
points(ps(model@response)$set, col = 'blue', pch = 19)
# ----------------
# Viennet
# ----------------
n <- 20
d <- 2
fun <- Viennet
doe <- replicate(d,sample(0:n,n))/n
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res)
model <- hEGO(model, fun, 80, quiet = FALSE)
pairs(ps(model@response)$set)
rgl::plot3d(ps(model@response)$set)
# ----------------
# Binh
# ----------------
n <- 20
d <- 2
fun <- Binh
doe <- cbind(rep(5,n), rep(3,n)) * replicate(d,sample(0:n,n))/n
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res, modelcontrol = list(objectives = 1:2))
model <- hEGO(model, fun, 40, upper = c(5,3), quiet = FALSE)
fun <- function(x) Binh(x)[c(1,2)]
gfun <- function(x) -Binh(x)[-c(1,2)]
tpf <- mco::nsga2(fun, d, 2, lower.bounds = c(0,0), upper.bounds = c(5,3),
                   constraints = gfun, cdim = 2)$value
plot(tpf)
points(ps(model@response[which(model@feasible),model@objective])$set, col = 'blue', pch = 19)
# ----------------
# The Nowacki Beam
# ----------------
n <- 20
d <- 2
fun <- nowacki_beam
doe <- replicate(d,sample(0:n,n))/n
res <- t(apply(doe, 1, fun))
model <- mkm(doe, res, modelcontrol = list(objective = 1:2, lower = rep(0.1,d)))
model <- hEGO(model, fun, 80, quiet = FALSE, control = list(rho = 0.1))
fun <- function(x) nowacki_beam(x)[c(1,2)]
gfun <- function(x) -nowacki_beam(x)[-c(1,2)]
tpf <- mco::nsga2(fun, d, 2, lower.bounds = c(0,0), upper.bounds = c(1,1),
                   constraints = gfun, cdim = 4)$value
plot(tpf)
points(ps(model@response[which(model@feasible),model@objective])$set, col = 'blue', pch = 19)
}

